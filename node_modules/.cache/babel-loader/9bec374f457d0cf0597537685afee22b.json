{"ast":null,"code":"import React from 'react';\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \"/* .rus {\\n  --theme-color: hsl(262, 24%, 84%);\\n  --theme-background: hsl(262, 25%, 98%);\\n\\n  position: relative;\\n  padding: 10px;\\n  font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto,\\n    Oxygen-Sans, Ubuntu, Cantarell, \\\"Helvetica Neue\\\", Helvetica, Arial,\\n    sans-serif;\\n  background-color: var(--theme-background);\\n  border: 1px dashed var(--theme-color);\\n  border-radius: 5px;\\n  cursor: pointer;\\n} */\\n\\n.rp-stage {\\n  position: relative;\\n  font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto,\\n    Oxygen-Sans, Ubuntu, Cantarell, \\\"Helvetica Neue\\\", Helvetica, Arial,\\n    sans-serif;\\n}\\n\\n.rp-image {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.rp-shapes {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n}\\n\\n.rp-selected-input {\\n  position: absolute;\\n}\\n\\n.rp-delete {\\n  width: 20px;\\n  height: 20px;\\n  fill: white;\\n}\\n\\n.rp-delete-section {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.rp-default-input-section {\\n  display: flex;\\n  align-items: stretch;\\n  background-color: #3384ff;\\n  border: none;\\n  border-radius: 5px;\\n}\\n\\n.rp-default-input-section input {\\n  padding: 10px;\\n  color: white;\\n  background: transparent;\\n  border: 0;\\n  outline: none;\\n}\\n\\n.rp-default-input-section input::placeholder {\\n  color: #94bfff;\\n}\\n\\n.rp-default-input-section a {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 35px;\\n  color: white;\\n  font-size: 12px;\\n  background-color: #3b5bdb;\\n  border-radius: 0 5px 5px 0;\\n  cursor: pointer;\\n  transition: background-color 0.5s, color 0.5s;\\n}\\n\\n.rp-default-input-section a:hover,\\n.rp-default-input-section a:active {\\n  color: #3384ff;\\n  background-color: #5c7cfa;\\n}\\n\";\nstyleInject(css);\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar shapeStyle = {\n  padding: 5,\n  margin: 10,\n  fontSize: 12,\n  fontColor: \"#212529\",\n  fontBackground: \"#f8f9fa\",\n  fontFamily: \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', Helvetica, Arial, sans-serif\",\n  shapeBackground: \"hsla(210, 16%, 93%, 0.2)\",\n  shapeStrokeStyle: \"#f8f9fa\",\n  shapeShadowStyle: \"hsla(210, 9%, 31%, 0.35)\"\n};\n\nvar RectShape = function RectShape(_data, onChange) {\n  var _this = this;\n\n  _classCallCheck(this, RectShape);\n\n  _defineProperty(this, \"annotationData\", void 0);\n\n  _defineProperty(this, \"onChangeCallBack\", void 0);\n\n  _defineProperty(this, \"dragStartOffset\", void 0);\n\n  _defineProperty(this, \"onDragStart\", function (positionX, positionY) {\n    var _this$annotationData$ = _this.annotationData.mark,\n        x = _this$annotationData$.x,\n        y = _this$annotationData$.y;\n    _this.dragStartOffset = {\n      offsetX: positionX - x,\n      offsetY: positionY - y\n    };\n  });\n\n  _defineProperty(this, \"onDrag\", function (positionX, positionY) {\n    _this.annotationData.mark.x = positionX - _this.dragStartOffset.offsetX;\n    _this.annotationData.mark.y = positionY - _this.dragStartOffset.offsetY;\n\n    _this.onChangeCallBack();\n  });\n\n  _defineProperty(this, \"checkBoundary\", function (positionX, positionY) {\n    var _this$annotationData$2 = _this.annotationData.mark,\n        x = _this$annotationData$2.x,\n        y = _this$annotationData$2.y,\n        width = _this$annotationData$2.width,\n        height = _this$annotationData$2.height;\n\n    if ((positionX > x && positionX < x + width || positionX < x && positionX > x + width) && (positionY > y && positionY < y + height || positionY < y && positionY > y + height)) {\n      return true;\n    }\n\n    return false;\n  });\n\n  _defineProperty(this, \"paint\", function (canvas2D, calculateTruePosition, selected) {\n    var _calculateTruePositio = calculateTruePosition(_this.annotationData.mark),\n        x = _calculateTruePositio.x,\n        y = _calculateTruePositio.y,\n        width = _calculateTruePositio.width,\n        height = _calculateTruePositio.height;\n\n    canvas2D.save();\n    canvas2D.shadowBlur = 10;\n    canvas2D.shadowColor = shapeStyle.shapeShadowStyle;\n    canvas2D.strokeStyle = shapeStyle.shapeStrokeStyle;\n    canvas2D.lineWidth = 2;\n    canvas2D.strokeRect(x, y, width, height);\n    canvas2D.restore();\n\n    if (selected) {\n      canvas2D.fillStyle = shapeStyle.shapeBackground;\n      canvas2D.fillRect(x, y, width, height);\n    } else {\n      var _comment = _this.annotationData.comment;\n\n      if (_comment) {\n        canvas2D.font = \"\".concat(shapeStyle.fontSize, \"px \").concat(shapeStyle.fontFamily);\n        var metrics = canvas2D.measureText(_comment);\n        canvas2D.save();\n        canvas2D.fillStyle = shapeStyle.fontBackground;\n        canvas2D.fillRect(x, y, metrics.width + shapeStyle.padding * 2, shapeStyle.fontSize + shapeStyle.padding * 2);\n        canvas2D.textBaseline = \"top\";\n        canvas2D.fillStyle = shapeStyle.fontColor;\n        canvas2D.fillText(_comment, x + shapeStyle.padding, y + shapeStyle.padding);\n      }\n    }\n\n    canvas2D.restore();\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  });\n\n  _defineProperty(this, \"adjustMark\", function (_ref) {\n    var _ref$x = _ref.x,\n        x = _ref$x === void 0 ? _this.annotationData.mark.x : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === void 0 ? _this.annotationData.mark.y : _ref$y,\n        _ref$width = _ref.width,\n        width = _ref$width === void 0 ? _this.annotationData.mark.width : _ref$width,\n        _ref$height = _ref.height,\n        height = _ref$height === void 0 ? _this.annotationData.mark.height : _ref$height;\n    _this.annotationData.mark.x = x;\n    _this.annotationData.mark.y = y;\n    _this.annotationData.mark.width = width;\n    _this.annotationData.mark.height = height;\n\n    _this.onChangeCallBack();\n  });\n\n  _defineProperty(this, \"getAnnotationData\", function () {\n    return _this.annotationData;\n  });\n\n  _defineProperty(this, \"setComment\", function (comment) {\n    _this.annotationData.comment = comment;\n  });\n\n  _defineProperty(this, \"equal\", function (data) {\n    return data.id === _this.annotationData.id && data.comment === _this.annotationData.comment && data.mark.x === _this.annotationData.mark.x && data.mark.y === _this.annotationData.mark.y && data.mark.width === _this.annotationData.mark.width && data.mark.height === _this.annotationData.mark.height;\n  });\n\n  this.annotationData = _data;\n  this.onChangeCallBack = onChange;\n};\n\nvar NODE_WIDTH = 10;\n\nvar Transformer = function Transformer(_shape) {\n  var _this = this;\n\n  _classCallCheck(this, Transformer);\n\n  _defineProperty(this, \"shape\", void 0);\n\n  _defineProperty(this, \"currentNodeCenterIndex\", void 0);\n\n  _defineProperty(this, \"checkBoundary\", function (positionX, positionY) {\n    var currentCenterIndex = _this.getCenterIndexByCursor(positionX, positionY);\n\n    return currentCenterIndex >= 0;\n  });\n\n  _defineProperty(this, \"startTransformation\", function (positionX, positionY) {\n    var currentCenterIndex = _this.getCenterIndexByCursor(positionX, positionY);\n\n    _this.currentNodeCenterIndex = currentCenterIndex;\n  });\n\n  _defineProperty(this, \"onTransformation\", function (positionX, positionY) {\n    var currentCentersTable = _this.getAllCentersTable();\n\n    currentCentersTable[_this.currentNodeCenterIndex].adjust(positionX, positionY);\n  });\n\n  _defineProperty(this, \"paint\", function (canvas2D, calculateTruePosition) {\n    var allCentersTable = _this.getAllCentersTable();\n\n    canvas2D.save();\n    canvas2D.fillStyle = \"#5c7cfa\";\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = allCentersTable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n\n        var _calculateTruePositio = calculateTruePosition({\n          x: item.x - NODE_WIDTH / 2,\n          y: item.y - NODE_WIDTH / 2,\n          width: NODE_WIDTH,\n          height: NODE_WIDTH\n        }),\n            x = _calculateTruePositio.x,\n            y = _calculateTruePositio.y,\n            width = _calculateTruePositio.width,\n            height = _calculateTruePositio.height;\n\n        canvas2D.fillRect(x, y, width, height);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    canvas2D.restore();\n  });\n\n  _defineProperty(this, \"getCenterIndexByCursor\", function (positionX, positionY) {\n    var allCentersTable = _this.getAllCentersTable();\n\n    return allCentersTable.findIndex(function (item) {\n      return _this.checkEachRectBoundary(item.x, item.y, positionX, positionY);\n    });\n  });\n\n  _defineProperty(this, \"checkEachRectBoundary\", function (rectCenterX, rectCenterY, positionX, positionY) {\n    if (Math.abs(positionX - rectCenterX) <= NODE_WIDTH / 2 && Math.abs(positionY - rectCenterY) <= NODE_WIDTH / 2) {\n      return true;\n    }\n\n    return false;\n  });\n\n  _defineProperty(this, \"getAllCentersTable\", function () {\n    var shape = _this.shape;\n    var _shape$getAnnotationD = shape.getAnnotationData().mark,\n        x = _shape$getAnnotationD.x,\n        y = _shape$getAnnotationD.y,\n        width = _shape$getAnnotationD.width,\n        height = _shape$getAnnotationD.height;\n    return [{\n      x: x,\n      y: y,\n      adjust: function adjust(positionX, positionY) {\n        shape.adjustMark({\n          x: positionX,\n          y: positionY,\n          width: width + x - positionX,\n          height: height + y - positionY\n        });\n      }\n    }, {\n      x: x + width / 2,\n      y: y,\n      adjust: function adjust(_, positionY) {\n        shape.adjustMark({\n          y: positionY,\n          height: height + y - positionY\n        });\n      }\n    }, {\n      x: x + width,\n      y: y,\n      adjust: function adjust(positionX, positionY) {\n        shape.adjustMark({\n          x: x,\n          y: positionY,\n          width: positionX - x,\n          height: y + height - positionY\n        });\n      }\n    }, {\n      x: x,\n      y: y + height / 2,\n      adjust: function adjust(positionX) {\n        shape.adjustMark({\n          x: positionX,\n          width: width + x - positionX\n        });\n      }\n    }, {\n      x: x + width,\n      y: y + height / 2,\n      adjust: function adjust(positionX) {\n        shape.adjustMark({\n          width: positionX - x\n        });\n      }\n    }, {\n      x: x,\n      y: y + height,\n      adjust: function adjust(positionX, positionY) {\n        shape.adjustMark({\n          x: positionX,\n          width: width + x - positionX,\n          height: positionY - y\n        });\n      }\n    }, {\n      x: x + width / 2,\n      y: y + height,\n      adjust: function adjust(_, positionY) {\n        shape.adjustMark({\n          height: positionY - y\n        });\n      }\n    }, {\n      x: x + width,\n      y: y + height,\n      adjust: function adjust(positionX, positionY) {\n        shape.adjustMark({\n          width: positionX - x,\n          height: positionY - y\n        });\n      }\n    }];\n  });\n\n  this.shape = _shape;\n};\n\nvar randomId = function randomId() {\n  var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n  var chars = \"ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678\";\n  var maxPos = chars.length;\n  var id = \"\";\n\n  for (var i = 0; i < len; i++) {\n    id += chars.charAt(Math.floor(Math.random() * maxPos));\n  }\n\n  return id;\n};\n\nvar CreatingAnnotationState = function CreatingAnnotationState(context) {\n  var _this = this;\n\n  _classCallCheck(this, CreatingAnnotationState);\n\n  _defineProperty(this, \"context\", void 0);\n\n  _defineProperty(this, \"onMouseDown\", function () {\n    return undefined;\n  });\n\n  _defineProperty(this, \"onMouseMove\", function (positionX, positionY) {\n    var shapes = _this.context.shapes;\n\n    if (shapes.length > 0) {\n      var currentShape = shapes[shapes.length - 1];\n\n      var _currentShape$getAnno = currentShape.getAnnotationData(),\n          _currentShape$getAnno2 = _currentShape$getAnno.mark,\n          x = _currentShape$getAnno2.x,\n          y = _currentShape$getAnno2.y;\n\n      currentShape.adjustMark({\n        width: positionX - x,\n        height: positionY - y\n      });\n    }\n  });\n\n  _defineProperty(this, \"onMouseUp\", function () {\n    var _this$context = _this.context,\n        shapes = _this$context.shapes,\n        onShapeChange = _this$context.onShapeChange,\n        setAnnotationState = _this$context.setAnnotationState;\n    var data = shapes.pop();\n\n    if (data && data.getAnnotationData().mark.width !== 0 && data.getAnnotationData().mark.height !== 0) {\n      shapes.push(data);\n    } else {\n      _this.context.selectedId = null;\n      onShapeChange();\n    }\n\n    setAnnotationState(new DefaultAnnotationState(_this.context));\n  });\n\n  _defineProperty(this, \"onMouseLeave\", function () {\n    return _this.onMouseUp();\n  });\n\n  this.context = context;\n};\n\nvar DraggingAnnotationState = function DraggingAnnotationState(context) {\n  var _this = this;\n\n  _classCallCheck(this, DraggingAnnotationState);\n\n  _defineProperty(this, \"context\", void 0);\n\n  _defineProperty(this, \"onMouseDown\", function () {\n    return undefined;\n  });\n\n  _defineProperty(this, \"onMouseMove\", function (positionX, positionY) {\n    var shapes = _this.context.shapes;\n    var currentShape = shapes[shapes.length - 1];\n    currentShape.onDrag(positionX, positionY);\n  });\n\n  _defineProperty(this, \"onMouseUp\", function () {\n    var setAnnotationState = _this.context.setAnnotationState;\n    setAnnotationState(new DefaultAnnotationState(_this.context));\n  });\n\n  _defineProperty(this, \"onMouseLeave\", function () {\n    return _this.onMouseUp();\n  });\n\n  this.context = context;\n};\n\nvar TransformationState = function TransformationState(context) {\n  var _this = this;\n\n  _classCallCheck(this, TransformationState);\n\n  _defineProperty(this, \"context\", void 0);\n\n  _defineProperty(this, \"onMouseDown\", function () {\n    return undefined;\n  });\n\n  _defineProperty(this, \"onMouseMove\", function (positionX, positionY) {\n    var currentTransformer = _this.context.currentTransformer;\n\n    if (currentTransformer) {\n      currentTransformer.onTransformation(positionX, positionY);\n    }\n  });\n\n  _defineProperty(this, \"onMouseUp\", function () {\n    var setAnnotationState = _this.context.setAnnotationState;\n    setAnnotationState(new DefaultAnnotationState(_this.context));\n  });\n\n  _defineProperty(this, \"onMouseLeave\", function () {\n    return _this.onMouseUp();\n  });\n\n  this.context = context;\n};\n\nvar DefaultAnnotationState = function DefaultAnnotationState(context) {\n  var _this = this;\n\n  _classCallCheck(this, DefaultAnnotationState);\n\n  _defineProperty(this, \"context\", void 0);\n\n  _defineProperty(this, \"onMouseMove\", function () {\n    return undefined;\n  });\n\n  _defineProperty(this, \"onMouseUp\", function () {\n    return undefined;\n  });\n\n  _defineProperty(this, \"onMouseLeave\", function () {\n    return undefined;\n  });\n\n  _defineProperty(this, \"onMouseDown\", function (positionX, positionY) {\n    var _this$context = _this.context,\n        shapes = _this$context.shapes,\n        currentTransformer = _this$context.currentTransformer,\n        onShapeChange = _this$context.onShapeChange,\n        setState = _this$context.setAnnotationState;\n\n    if (currentTransformer && currentTransformer.checkBoundary(positionX, positionY)) {\n      currentTransformer.startTransformation(positionX, positionY);\n      setState(new TransformationState(_this.context));\n      return;\n    }\n\n    for (var i = shapes.length - 1; i >= 0; i--) {\n      if (shapes[i].checkBoundary(positionX, positionY)) {\n        _this.context.selectedId = shapes[i].getAnnotationData().id;\n        _this.context.currentTransformer = new Transformer(shapes[i]);\n\n        var _shapes$splice = shapes.splice(i, 1),\n            _shapes$splice2 = _slicedToArray(_shapes$splice, 1),\n            selectedShape = _shapes$splice2[0];\n\n        shapes.push(selectedShape);\n        selectedShape.onDragStart(positionX, positionY);\n        onShapeChange();\n        setState(new DraggingAnnotationState(_this.context));\n        return;\n      }\n    }\n\n    _this.context.shapes.push(new RectShape({\n      id: randomId(),\n      mark: {\n        x: positionX,\n        y: positionY,\n        width: 0,\n        height: 0,\n        type: \"RECT\"\n      }\n    }, onShapeChange));\n\n    setState(new CreatingAnnotationState(_this.context));\n  });\n\n  this.context = context;\n};\n\nvar DeleteButton = function DeleteButton() {\n  return React.createElement(\"svg\", {\n    className: \"rp-delete\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 24 24\"\n  }, React.createElement(\"g\", {\n    \"data-name\": \"Layer 2\"\n  }, React.createElement(\"g\", {\n    \"data-name\": \"trash-2\"\n  }, React.createElement(\"rect\", {\n    width: \"24\",\n    height: \"24\",\n    opacity: \"0\"\n  }), React.createElement(\"path\", {\n    d: \"M21 6h-5V4.33A2.42 2.42 0 0 0 13.5 2h-3A2.42 2.42 0 0 0 8 4.33V6H3a1 1 0 0 0 0 2h1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8h1a1 1 0 0 0 0-2zM10 16a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0zm0-11.67c0-.16.21-.33.5-.33h3c.29 0 .5.17.5.33V6h-4zM16 16a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0z\"\n  }))));\n};\n\nvar DefaultInputSection = function DefaultInputSection(_ref) {\n  var value = _ref.value,\n      _onChange = _ref.onChange,\n      onDelete = _ref.onDelete;\n  return React.createElement(\"div\", {\n    className: \"rp-default-input-section\"\n  }, React.createElement(\"input\", {\n    className: \"rp-default-input-section_input\",\n    placeholder: \"INPUT TAG HERE\",\n    value: value,\n    onChange: function onChange(e) {\n      return _onChange(e.target.value);\n    }\n  }), React.createElement(\"a\", {\n    className: \"rp-default-input-section_delete\",\n    onClick: function onClick() {\n      return onDelete();\n    }\n  }, React.createElement(DeleteButton, null)));\n};\n\nvar defaultState = {\n  scale: 1,\n  originX: 0,\n  originY: 0\n};\n\nvar ReactPictureAnnotation = /*#__PURE__*/function (_React$Component) {\n  _inherits(ReactPictureAnnotation, _React$Component);\n\n  function ReactPictureAnnotation() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, ReactPictureAnnotation);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ReactPictureAnnotation)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"shapes\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentTransformer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      inputPosition: {\n        left: 0,\n        top: 0\n      },\n      showInput: false,\n      inputComment: \"\"\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"currentAnnotationData\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"selectedIdTrueValue\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"canvasRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"canvas2D\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"imageCanvasRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"imageCanvas2D\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentImageElement\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"currentAnnotationState\", new DefaultAnnotationState(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"scaleState\", defaultState);\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function () {\n      var currentCanvas = _this.canvasRef.current;\n      var currentImageCanvas = _this.imageCanvasRef.current;\n\n      if (currentCanvas && currentImageCanvas) {\n        _this.setCanvasDPI();\n\n        _this.canvas2D = currentCanvas.getContext(\"2d\");\n        _this.imageCanvas2D = currentImageCanvas.getContext(\"2d\");\n\n        _this.onImageChange();\n      }\n\n      _this.syncAnnotationData();\n\n      _this.syncSelectedId();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function (preProps) {\n      var _this$props = _this.props,\n          width = _this$props.width,\n          height = _this$props.height,\n          image = _this$props.image;\n\n      if (preProps.width !== width || preProps.height !== height) {\n        _this.setCanvasDPI();\n\n        _this.onShapeChange();\n\n        _this.onImageChange();\n      }\n\n      if (preProps.image !== image) {\n        _this.cleanImage();\n\n        if (_this.currentImageElement) {\n          _this.currentImageElement.src = image;\n        } else {\n          _this.onImageChange();\n        }\n      }\n\n      _this.syncAnnotationData();\n\n      _this.syncSelectedId();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"calculateMousePosition\", function (positionX, positionY) {\n      var _this$scaleState = _this.scaleState,\n          originX = _this$scaleState.originX,\n          originY = _this$scaleState.originY,\n          scale = _this$scaleState.scale;\n      return {\n        positionX: (positionX - originX) / scale,\n        positionY: (positionY - originY) / scale\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"calculateShapePosition\", function (shapeData) {\n      var _this$scaleState2 = _this.scaleState,\n          originX = _this$scaleState2.originX,\n          originY = _this$scaleState2.originY,\n          scale = _this$scaleState2.scale;\n      var x = shapeData.x,\n          y = shapeData.y,\n          width = shapeData.width,\n          height = shapeData.height;\n      return {\n        x: x * scale + originX,\n        y: y * scale + originY,\n        width: width * scale,\n        height: height * scale\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setAnnotationState\", function (annotationState) {\n      _this.currentAnnotationState = annotationState;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onShapeChange\", function () {\n      if (_this.canvas2D && _this.canvasRef.current) {\n        _this.canvas2D.clearRect(0, 0, _this.canvasRef.current.width, _this.canvasRef.current.height);\n\n        var hasSelectedItem = false;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _this.shapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            var isSelected = item.getAnnotationData().id === _this.selectedId;\n\n            var _item$paint = item.paint(_this.canvas2D, _this.calculateShapePosition, isSelected),\n                x = _item$paint.x,\n                y = _item$paint.y,\n                height = _item$paint.height;\n\n            if (isSelected) {\n              if (!_this.currentTransformer) {\n                _this.currentTransformer = new Transformer(item);\n              }\n\n              hasSelectedItem = true;\n\n              _this.currentTransformer.paint(_this.canvas2D, _this.calculateShapePosition);\n\n              _this.setState({\n                showInput: true,\n                inputPosition: {\n                  left: x,\n                  top: y + height + shapeStyle.margin\n                },\n                inputComment: item.getAnnotationData().comment || \"\"\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (!hasSelectedItem) {\n          _this.setState({\n            showInput: false,\n            inputComment: \"\"\n          });\n        }\n      }\n\n      _this.currentAnnotationData = _this.shapes.map(function (item) {\n        return item.getAnnotationData();\n      });\n      var onChange = _this.props.onChange;\n      onChange(_this.currentAnnotationData);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"syncAnnotationData\", function () {\n      var annotationData = _this.props.annotationData;\n\n      if (annotationData) {\n        var refreshShapesWithAnnotationData = function refreshShapesWithAnnotationData() {\n          _this.selectedId = null;\n          var nextShapes = annotationData.map(function (eachAnnotationData) {\n            return new RectShape(eachAnnotationData, _this.onShapeChange);\n          });\n          _this.shapes = nextShapes;\n\n          _this.onShapeChange();\n        };\n\n        if (annotationData.length !== _this.shapes.length) {\n          refreshShapesWithAnnotationData();\n        } else {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            var _loop2 = function _loop2() {\n              var annotationDataItem = _step2.value;\n\n              var targetShape = _this.shapes.find(function (item) {\n                return item.getAnnotationData().id === annotationDataItem.id;\n              });\n\n              if (targetShape && targetShape.equal(annotationDataItem)) {\n                return \"continue\";\n              } else {\n                refreshShapesWithAnnotationData();\n                return \"break\";\n              }\n            };\n\n            _loop: for (var _iterator2 = annotationData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _ret = _loop2();\n\n              switch (_ret) {\n                case \"continue\":\n                  continue;\n\n                case \"break\":\n                  break _loop;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"syncSelectedId\", function () {\n      var selectedId = _this.props.selectedId;\n\n      if (selectedId && selectedId !== _this.selectedId) {\n        _this.selectedId = selectedId;\n\n        _this.onShapeChange();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDelete\", function () {\n      var deleteTarget = _this.shapes.findIndex(function (shape) {\n        return shape.getAnnotationData().id === _this.selectedId;\n      });\n\n      if (deleteTarget >= 0) {\n        _this.shapes.splice(deleteTarget, 1);\n\n        _this.onShapeChange();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setCanvasDPI\", function () {\n      var currentCanvas = _this.canvasRef.current;\n      var currentImageCanvas = _this.imageCanvasRef.current;\n\n      if (currentCanvas && currentImageCanvas) {\n        var currentCanvas2D = currentCanvas.getContext(\"2d\");\n        var currentImageCanvas2D = currentImageCanvas.getContext(\"2d\");\n\n        if (currentCanvas2D && currentImageCanvas2D) {\n          currentCanvas2D.scale(2, 2);\n          currentImageCanvas2D.scale(2, 2);\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onInputCommentChange\", function (comment) {\n      var selectedShapeIndex = _this.shapes.findIndex(function (item) {\n        return item.getAnnotationData().id === _this.selectedId;\n      });\n\n      _this.shapes[selectedShapeIndex].setComment(comment);\n\n      _this.setState({\n        inputComment: comment\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"cleanImage\", function () {\n      if (_this.imageCanvas2D && _this.imageCanvasRef.current) {\n        _this.imageCanvas2D.clearRect(0, 0, _this.imageCanvasRef.current.width, _this.imageCanvasRef.current.height);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onImageChange\", function () {\n      _this.cleanImage();\n\n      if (_this.imageCanvas2D && _this.imageCanvasRef.current) {\n        if (_this.currentImageElement) {\n          var _this$scaleState3 = _this.scaleState,\n              originX = _this$scaleState3.originX,\n              originY = _this$scaleState3.originY,\n              scale = _this$scaleState3.scale;\n\n          _this.imageCanvas2D.drawImage(_this.currentImageElement, originX, originY, _this.currentImageElement.width * scale, _this.currentImageElement.height * scale);\n        } else {\n          var nextImageNode = document.createElement(\"img\");\n          nextImageNode.addEventListener(\"load\", function () {\n            _this.currentImageElement = nextImageNode;\n            var width = nextImageNode.width,\n                height = nextImageNode.height;\n            var imageNodeRatio = height / width;\n            var _this$props2 = _this.props,\n                canvasWidth = _this$props2.width,\n                canvasHeight = _this$props2.height;\n            var canvasNodeRatio = canvasHeight / canvasWidth;\n\n            if (!isNaN(imageNodeRatio) && !isNaN(canvasNodeRatio)) {\n              if (imageNodeRatio < canvasNodeRatio) {\n                var _scale = canvasWidth / width;\n\n                _this.scaleState = {\n                  originX: 0,\n                  originY: (canvasHeight - _scale * height) / 2,\n                  scale: _scale\n                };\n              } else {\n                var _scale2 = canvasHeight / height;\n\n                _this.scaleState = {\n                  originX: (canvasWidth - _scale2 * width) / 2,\n                  originY: 0,\n                  scale: _scale2\n                };\n              }\n            }\n\n            _this.onImageChange();\n\n            _this.onShapeChange();\n          });\n          nextImageNode.alt = \"\";\n          nextImageNode.src = _this.props.image;\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMouseDown\", function (event) {\n      var _event$nativeEvent = event.nativeEvent,\n          offsetX = _event$nativeEvent.offsetX,\n          offsetY = _event$nativeEvent.offsetY;\n\n      var _this$calculateMouseP = _this.calculateMousePosition(offsetX, offsetY),\n          positionX = _this$calculateMouseP.positionX,\n          positionY = _this$calculateMouseP.positionY;\n\n      _this.currentAnnotationState.onMouseDown(positionX, positionY);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMouseMove\", function (event) {\n      var _event$nativeEvent2 = event.nativeEvent,\n          offsetX = _event$nativeEvent2.offsetX,\n          offsetY = _event$nativeEvent2.offsetY;\n\n      var _this$calculateMouseP2 = _this.calculateMousePosition(offsetX, offsetY),\n          positionX = _this$calculateMouseP2.positionX,\n          positionY = _this$calculateMouseP2.positionY;\n\n      _this.currentAnnotationState.onMouseMove(positionX, positionY);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMouseUp\", function () {\n      _this.currentAnnotationState.onMouseUp();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMouseLeave\", function () {\n      _this.currentAnnotationState.onMouseLeave();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onWheel\", function (event) {\n      // https://stackoverflow.com/a/31133823/9071503\n      var _event$currentTarget = event.currentTarget,\n          clientHeight = _event$currentTarget.clientHeight,\n          scrollTop = _event$currentTarget.scrollTop,\n          scrollHeight = _event$currentTarget.scrollHeight;\n\n      if (clientHeight + scrollTop + event.deltaY > scrollHeight) {\n        // event.preventDefault();\n        event.currentTarget.scrollTop = scrollHeight;\n      } else if (scrollTop + event.deltaY < 0) {\n        // event.preventDefault();\n        event.currentTarget.scrollTop = 0;\n      }\n\n      var preScale = _this.scaleState.scale;\n      _this.scaleState.scale += event.deltaY * 0.005;\n\n      if (_this.scaleState.scale > 10) {\n        _this.scaleState.scale = 10;\n      }\n\n      if (_this.scaleState.scale < 0.1) {\n        _this.scaleState.scale = 0.1;\n      }\n\n      var _this$scaleState4 = _this.scaleState,\n          originX = _this$scaleState4.originX,\n          originY = _this$scaleState4.originY,\n          scale = _this$scaleState4.scale;\n      var _event$nativeEvent3 = event.nativeEvent,\n          offsetX = _event$nativeEvent3.offsetX,\n          offsetY = _event$nativeEvent3.offsetY;\n      _this.scaleState.originX = offsetX - (offsetX - originX) / preScale * scale;\n      _this.scaleState.originY = offsetY - (offsetY - originY) / preScale * scale;\n\n      _this.setState({\n        imageScale: _this.scaleState\n      });\n\n      requestAnimationFrame(function () {\n        _this.onShapeChange();\n\n        _this.onImageChange();\n      });\n    });\n\n    return _this;\n  }\n\n  _createClass(ReactPictureAnnotation, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          width = _this$props3.width,\n          height = _this$props3.height,\n          inputElement = _this$props3.inputElement;\n      var _this$state = this.state,\n          showInput = _this$state.showInput,\n          inputPosition = _this$state.inputPosition,\n          inputComment = _this$state.inputComment;\n      return React.createElement(\"div\", {\n        className: \"rp-stage\"\n      }, React.createElement(\"canvas\", {\n        style: {\n          width: width,\n          height: height\n        },\n        className: \"rp-image\",\n        ref: this.imageCanvasRef,\n        width: width * 2,\n        height: height * 2\n      }), React.createElement(\"canvas\", {\n        className: \"rp-shapes\",\n        style: {\n          width: width,\n          height: height\n        },\n        ref: this.canvasRef,\n        width: width * 2,\n        height: height * 2,\n        onMouseDown: this.onMouseDown,\n        onMouseMove: this.onMouseMove,\n        onMouseUp: this.onMouseUp,\n        onMouseLeave: this.onMouseLeave,\n        onWheel: this.onWheel\n      }), showInput && React.createElement(\"div\", {\n        className: \"rp-selected-input\",\n        style: inputPosition\n      }, inputElement(inputComment, this.onInputCommentChange, this.onDelete)));\n    }\n  }, {\n    key: \"selectedId\",\n    set: function set(value) {\n      var onSelect = this.props.onSelect;\n      this.selectedIdTrueValue = value;\n      onSelect(value);\n    },\n    get: function get() {\n      return this.selectedIdTrueValue;\n    }\n  }]);\n\n  return ReactPictureAnnotation;\n}(React.Component);\n\n_defineProperty(ReactPictureAnnotation, \"defaultProps\", {\n  inputElement: function inputElement(value, onChange, onDelete) {\n    return React.createElement(DefaultInputSection, {\n      value: value,\n      onChange: onChange,\n      onDelete: onDelete\n    });\n  }\n});\n\nexport { DefaultInputSection, ReactPictureAnnotation };","map":null,"metadata":{},"sourceType":"module"}