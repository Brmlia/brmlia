{"ast":null,"code":"import _objectSpread from \"/Users/ramiroochoa/Desktop/brmlia/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"/Users/ramiroochoa/Desktop/brmlia/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/ramiroochoa/Desktop/brmlia/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/ramiroochoa/Desktop/brmlia/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport create from 'zustand';\nimport * as THREE from 'three'; //import Tiff from 'tiff.js';\n\nimport UTIF from 'utif';\nexport var createTexture = function createTexture(image) {\n  return new THREE.TextureLoader().load(image);\n};\nexport var createTextureFromTiff = function createTextureFromTiff(image) {\n  //use async and promises to load the blob into a buffer, then decode it\n  //into an RGBA Uint8Array. Load the array into a DataTexture\n  function fetchImageBuffer(_x) {\n    return _fetchImageBuffer.apply(this, arguments);\n  }\n\n  function _fetchImageBuffer() {\n    _fetchImageBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(image) {\n      var blob, arrayBuffer;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // function input 'image' is already a blob,\n              // but it was not working without explicitly creating the Blob...\n              blob = new Blob([image]);\n              _context.next = 3;\n              return new Response(blob).arrayBuffer();\n\n            case 3:\n              arrayBuffer = _context.sent;\n              return _context.abrupt(\"return\", arrayBuffer);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _fetchImageBuffer.apply(this, arguments);\n  }\n\n  fetchImageBuffer().then(function (blob) {\n    var byteLength = blob.byteLength;\n    console.log(byteLength);\n\n    if (byteLength > 0) {\n      var ifds = UTIF.decode(blob);\n      UTIF.decodeImage(blob, ifds[0]);\n      var rgba = UTIF.toRGBA8(ifds[0]); // Uint8Array with RGBA pixels\n      //console.log(\"WIDTH: \" + ifds[0].width, \"HEIGHT: \" + ifds[0].height, ifds[0]);\n\n      return rgba;\n    }\n  }).catch(function (e) {\n    return console.log(e);\n  });\n  var canv = fetchImageBuffer(image);\n  Promise.resolve(canv).then(function (canv) {\n    console.log('Uint8Array with RGBA pixel length: ' + canv.byteLength); // use DataTexture to load the RGBA Uint8Array into a texture\n    // https://threejs.org/docs/index.html#api/en/textures/DataTexture\n    // TODO: Get the actual height and width of the image for tiff spec\n\n    var dataView = new DataView(canv, 0, 28);\n    var width = 512; //dataView.getInt32(16);\n\n    var height = 512; //dataView.getInt32(20);\n\n    var texture = new THREE.DataTexture(canv, width, height, THREE.RGBFormat);\n    return texture;\n  }, function (canv) {});\n};\nvar initState = {\n  // todo: individual uniforms for separate channels\n  channels: [{\n    uniforms: {\n      brightness: {\n        value: '0.0'\n      },\n      contrast: {\n        value: '0.0'\n      },\n      image: {\n        value: ''\n      }\n    },\n    texture: null,\n    name: '',\n    type: ''\n  }, {\n    uniforms: {\n      brightness: {\n        value: '0.0'\n      },\n      contrast: {\n        value: '0.0'\n      },\n      image: {\n        value: ''\n      }\n    },\n    texture: null,\n    name: '',\n    type: ''\n  }, {\n    uniforms: {\n      brightness: {\n        value: '0.0'\n      },\n      contrast: {\n        value: '0.0'\n      },\n      image: {\n        value: ''\n      }\n    },\n    texture: null,\n    name: '',\n    type: ''\n  }]\n};\n\nvar _create = create(function (set) {\n  return _objectSpread({}, initState);\n}),\n    _create2 = _slicedToArray(_create, 2),\n    useUniformStore = _create2[0],\n    uniApi = _create2[1];\n\nexport { useUniformStore, uniApi };","map":{"version":3,"sources":["/Users/ramiroochoa/Desktop/brmlia/src/imagecanvas/imageStore.js"],"names":["create","THREE","UTIF","createTexture","image","TextureLoader","load","createTextureFromTiff","fetchImageBuffer","blob","Blob","Response","arrayBuffer","then","byteLength","console","log","ifds","decode","decodeImage","rgba","toRGBA8","catch","e","canv","Promise","resolve","dataView","DataView","width","height","texture","DataTexture","RGBFormat","initState","channels","uniforms","brightness","value","contrast","name","type","set","useUniformStore","uniApi"],"mappings":"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","sourcesContent":["import create from 'zustand';\nimport * as THREE from 'three';\n//import Tiff from 'tiff.js';\nimport UTIF from 'utif';\n\nexport const createTexture = (image) => {\n  return new THREE.TextureLoader().load(image);\n}\n\nexport const createTextureFromTiff = (image) => {\n\n  //use async and promises to load the blob into a buffer, then decode it\n  //into an RGBA Uint8Array. Load the array into a DataTexture\n  async function fetchImageBuffer(image) {\n    // function input 'image' is already a blob,\n    // but it was not working without explicitly creating the Blob...\n    const blob = new Blob([image]);\n    const arrayBuffer = await new Response(blob).arrayBuffer();\n    return arrayBuffer;\n  }\n  fetchImageBuffer().then((blob) => {\n    const byteLength = blob.byteLength;\n    console.log(byteLength);\n    if(byteLength > 0){\n      let ifds = UTIF.decode(blob);\n      UTIF.decodeImage(blob, ifds[0])\n      let rgba = UTIF.toRGBA8(ifds[0]);  // Uint8Array with RGBA pixels\n      //console.log(\"WIDTH: \" + ifds[0].width, \"HEIGHT: \" + ifds[0].height, ifds[0]);\n      return rgba;\n    }\n  })\n  .catch((e) =>\n    console.log(e)\n  );\n\n\n  const canv = fetchImageBuffer(image);\n  Promise.resolve(canv).then(function(canv) {\n    console.log('Uint8Array with RGBA pixel length: ' + canv.byteLength);\n    // use DataTexture to load the RGBA Uint8Array into a texture\n    // https://threejs.org/docs/index.html#api/en/textures/DataTexture\n    // TODO: Get the actual height and width of the image for tiff spec\n\n    let dataView = new DataView(canv, 0, 28);\n    let width = 512; //dataView.getInt32(16);\n    let height = 512; //dataView.getInt32(20);\n    let texture = new THREE.DataTexture( canv, width, height, THREE.RGBFormat );\n    return texture;\n  }, function(canv) {\n  });\n\n}\n\nconst initState = {\n  // todo: individual uniforms for separate channels\n  channels:\n    [\n      {\n        uniforms: {\n          brightness: {\n            value: '0.0'\n          },\n          contrast: {\n            value: '0.0'\n          },\n          image: {\n            value: ''\n          }\n        },\n        texture: null,\n        name: '',\n        type: ''\n      },\n      {\n\n        uniforms: {\n          brightness: {\n            value: '0.0'\n          },\n          contrast: {\n            value: '0.0'\n          },\n          image: {\n            value: ''\n          }\n        },\n        texture: null,\n        name: '',\n        type: ''\n      },\n      {\n\n        uniforms: {\n          brightness: {\n            value: '0.0'\n          },\n          contrast: {\n            value: '0.0'\n          },\n          image: {\n            value: ''\n          }\n        },\n        texture: null,\n        name: '',\n        type: ''\n      }\n    ]\n}\n\nexport const [useUniformStore, uniApi] = create ( set => ( {\n  ...initState,\n}))"]},"metadata":{},"sourceType":"module"}