{"ast":null,"code":"var _class, _temp2;\n\nvar _templateObject = _taggedTemplateLiteralLoose(['\\n  clear: both;\\n  position: relative;\\n  width: 100%;\\n  &:hover ', ' {\\n    opacity: 1;\\n  }\\n  touch-action: ', ';\\n'], ['\\n  clear: both;\\n  position: relative;\\n  width: 100%;\\n  &:hover ', ' {\\n    opacity: 1;\\n  }\\n  touch-action: ', ';\\n']),\n    _templateObject2 = _taggedTemplateLiteralLoose(['\\n  display: block;\\n  width: 100%;\\n'], ['\\n  display: block;\\n  width: 100%;\\n']),\n    _templateObject3 = _taggedTemplateLiteralLoose(['\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  right: 0;\\n'], ['\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  right: 0;\\n']);\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n}\n\nimport React, { Component } from 'react';\nimport T from 'prop-types';\nimport styled from 'styled-components';\nimport compose from '../utils/compose';\nimport isMouseHovering from '../utils/isMouseHovering';\nimport withRelativeMousePos from '../utils/withRelativeMousePos';\nimport defaultProps from './defaultProps';\nimport Overlay from './Overlay';\nvar Container = styled.div(_templateObject, Overlay, function (props) {\n  return props.allowTouch ? \"pinch-zoom\" : \"auto\";\n});\nvar Img = styled.img(_templateObject2);\nvar Items = styled.div(_templateObject3);\nvar Target = Items;\nexport default compose(isMouseHovering(), withRelativeMousePos())((_temp2 = _class = function (_Component) {\n  _inherits(Annotation, _Component);\n\n  function Annotation() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Annotation);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.targetRef = React.createRef(), _this.addTargetTouchEventListeners = function () {\n      // Safari does not recognize touch-action CSS property,\n      // so we need to call preventDefault ourselves to stop touch from scrolling\n      // Event handlers must be set via ref to enable e.preventDefault()\n      // https://github.com/facebook/react/issues/9809\n      _this.targetRef.current.ontouchstart = _this.onTouchStart;\n      _this.targetRef.current.ontouchend = _this.onTouchEnd;\n      _this.targetRef.current.ontouchmove = _this.onTargetTouchMove;\n      _this.targetRef.current.ontouchcancel = _this.onTargetTouchLeave;\n    }, _this.removeTargetTouchEventListeners = function () {\n      _this.targetRef.current.ontouchstart = undefined;\n      _this.targetRef.current.ontouchend = undefined;\n      _this.targetRef.current.ontouchmove = undefined;\n      _this.targetRef.current.ontouchcancel = undefined;\n    }, _this.setInnerRef = function (el) {\n      _this.container = el;\n\n      _this.props.relativeMousePos.innerRef(el);\n\n      _this.props.innerRef(el);\n    }, _this.getSelectorByType = function (type) {\n      return _this.props.selectors.find(function (s) {\n        return s.TYPE === type;\n      });\n    }, _this.getTopAnnotationAt = function (x, y) {\n      var annotations = _this.props.annotations;\n      var _this2 = _this,\n          container = _this2.container,\n          getSelectorByType = _this2.getSelectorByType;\n      if (!container) return;\n      var intersections = annotations.map(function (annotation) {\n        var geometry = annotation.geometry;\n        var selector = getSelectorByType(geometry.type);\n        return selector.intersects({\n          x: x,\n          y: y\n        }, geometry, container) ? annotation : false;\n      }).filter(function (a) {\n        return !!a;\n      }).sort(function (a, b) {\n        var aSelector = getSelectorByType(a.geometry.type);\n        var bSelector = getSelectorByType(b.geometry.type);\n        return aSelector.area(a.geometry, container) - bSelector.area(b.geometry, container);\n      });\n      return intersections[0];\n    }, _this.onTargetMouseMove = function (e) {\n      _this.props.relativeMousePos.onMouseMove(e);\n\n      _this.onMouseMove(e);\n    }, _this.onTargetTouchMove = function (e) {\n      _this.props.relativeMousePos.onTouchMove(e);\n\n      _this.onTouchMove(e);\n    }, _this.onTargetMouseLeave = function (e) {\n      _this.props.relativeMousePos.onMouseLeave(e);\n    }, _this.onTargetTouchLeave = function (e) {\n      _this.props.relativeMousePos.onTouchLeave(e);\n    }, _this.onMouseUp = function (e) {\n      return _this.callSelectorMethod('onMouseUp', e);\n    }, _this.onMouseDown = function (e) {\n      return _this.callSelectorMethod('onMouseDown', e);\n    }, _this.onMouseMove = function (e) {\n      return _this.callSelectorMethod('onMouseMove', e);\n    }, _this.onTouchStart = function (e) {\n      return _this.callSelectorMethod(\"onTouchStart\", e);\n    }, _this.onTouchEnd = function (e) {\n      return _this.callSelectorMethod(\"onTouchEnd\", e);\n    }, _this.onTouchMove = function (e) {\n      return _this.callSelectorMethod(\"onTouchMove\", e);\n    }, _this.onClick = function (e) {\n      return _this.callSelectorMethod('onClick', e);\n    }, _this.onSubmit = function () {\n      _this.props.onSubmit(_this.props.value);\n    }, _this.callSelectorMethod = function (methodName, e) {\n      if (_this.props.disableAnnotation) {\n        return;\n      }\n\n      if (!!_this.props[methodName]) {\n        _this.props[methodName](e);\n      } else {\n        var selector = _this.getSelectorByType(_this.props.type);\n\n        if (selector && selector.methods[methodName]) {\n          var value = selector.methods[methodName](_this.props.value, e);\n\n          if (typeof value === 'undefined') {\n            if (process.env.NODE_ENV !== 'production') {\n              console.error('\\n              ' + methodName + ' of selector type ' + _this.props.type + ' returned undefined.\\n              Make sure to explicitly return the previous state\\n            ');\n            }\n          } else {\n            _this.props.onChange(value);\n          }\n        }\n      }\n    }, _this.shouldAnnotationBeActive = function (annotation, top) {\n      if (_this.props.activeAnnotations) {\n        var isActive = !!_this.props.activeAnnotations.find(function (active) {\n          return _this.props.activeAnnotationComparator(annotation, active);\n        });\n        return isActive || top === annotation;\n      } else {\n        return top === annotation;\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Annotation.prototype.componentDidMount = function componentDidMount() {\n    if (this.props.allowTouch) {\n      this.addTargetTouchEventListeners();\n    }\n  };\n\n  Annotation.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.allowTouch !== prevProps.allowTouch) {\n      if (this.props.allowTouch) {\n        this.addTargetTouchEventListeners();\n      } else {\n        this.removeTargetTouchEventListeners();\n      }\n    }\n  };\n\n  Annotation.prototype.render = function render() {\n    var _this3 = this;\n\n    var props = this.props;\n    var isMouseHovering = props.isMouseHovering,\n        renderHighlight = props.renderHighlight,\n        renderContent = props.renderContent,\n        renderSelector = props.renderSelector,\n        renderEditor = props.renderEditor,\n        renderOverlay = props.renderOverlay,\n        allowTouch = props.allowTouch;\n    var topAnnotationAtMouse = this.getTopAnnotationAt(this.props.relativeMousePos.x, this.props.relativeMousePos.y);\n    return React.createElement(Container, {\n      style: props.style,\n      innerRef: isMouseHovering.innerRef,\n      onMouseLeave: this.onTargetMouseLeave,\n      onTouchCancel: this.onTargetTouchLeave,\n      allowTouch: allowTouch\n    }, React.createElement(Img, {\n      className: props.className,\n      style: props.style,\n      alt: props.alt,\n      src: props.src,\n      draggable: false,\n      innerRef: this.setInnerRef\n    }), React.createElement(Items, null, props.annotations.map(function (annotation) {\n      return renderHighlight({\n        key: annotation.data.id,\n        annotation: annotation,\n        active: _this3.shouldAnnotationBeActive(annotation, topAnnotationAtMouse)\n      });\n    }), !props.disableSelector && props.value && props.value.geometry && renderSelector({\n      annotation: props.value\n    })), React.createElement(Target, {\n      innerRef: this.targetRef,\n      onClick: this.onClick,\n      onMouseUp: this.onMouseUp,\n      onMouseDown: this.onMouseDown,\n      onMouseMove: this.onTargetMouseMove\n    }), !props.disableOverlay && renderOverlay({\n      type: props.type,\n      annotation: props.value\n    }), props.annotations.map(function (annotation) {\n      return _this3.shouldAnnotationBeActive(annotation, topAnnotationAtMouse) && renderContent({\n        key: annotation.data.id,\n        annotation: annotation\n      });\n    }), !props.disableEditor && props.value && props.value.selection && props.value.selection.showEditor && renderEditor({\n      annotation: props.value,\n      onChange: props.onChange,\n      onSubmit: this.onSubmit\n    }), React.createElement('div', null, props.children));\n  };\n\n  return Annotation;\n}(Component), _class.propTypes = {\n  innerRef: T.func,\n  onMouseUp: T.func,\n  onMouseDown: T.func,\n  onMouseMove: T.func,\n  onClick: T.func,\n  children: T.object,\n  annotations: T.arrayOf(T.shape({\n    type: T.string\n  })).isRequired,\n  type: T.string,\n  selectors: T.arrayOf(T.shape({\n    TYPE: T.string,\n    intersects: T.func.isRequired,\n    area: T.func.isRequired,\n    methods: T.object.isRequired\n  })).isRequired,\n  value: T.shape({\n    selection: T.object,\n    geometry: T.shape({\n      type: T.string.isRequired\n    }),\n    data: T.object\n  }),\n  onChange: T.func,\n  onSubmit: T.func,\n  activeAnnotationComparator: T.func,\n  activeAnnotations: T.arrayOf(T.any),\n  disableAnnotation: T.bool,\n  disableSelector: T.bool,\n  renderSelector: T.func,\n  disableEditor: T.bool,\n  renderEditor: T.func,\n  renderHighlight: T.func.isRequired,\n  renderContent: T.func.isRequired,\n  disableOverlay: T.bool,\n  renderOverlay: T.func.isRequired,\n  allowTouch: T.bool\n}, _class.defaultProps = defaultProps, _temp2));","map":null,"metadata":{},"sourceType":"module"}